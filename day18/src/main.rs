use std::{env, ops::Add, str::FromStr};

use petgraph::{graph::NodeIndex, visit::EdgeRef, EdgeDirection::Incoming, Graph};

/**
 * --- Day 18: Snailfish ---
 *
 * The program has to operate on a series of "snailfish numbers". Each Snailfish number is a pair.
 * Each element of the pair can be an integer from 0 to 9, or another snailfish number. Pairs can be
 * nested up to 3 times. Addition is defined as A + B = [A, B]. Adding numbers this way can break
 * the rule about nesting levels, which is why the concept of *reduction* is introduced. After
 * addition, the number has to be reduced until it does not break the rules anymore.
 *
 * Reduction is done by scanning the number "left to right" on its string interpretation. If at any
 * point it find some broken rule, it will fix it and start again from the beginning of the new
 * number. It does so until no rules are broken.
 *
 * The rules about nesting levels is fixed by "exploding". When a pair of numbers is found that is
 * nested 4 levels deep, it is exploded. It will always be 4 levels deep and it will always be a
 * pair of numbers (instead of a pair of pairs) because adding two valid snailfish numbers can't go
 * any further than that. "Exploding" a number means adding the left number of the pair to the first
 * individual number immediately to the left (if any) and the right number of the pair to the first
 * individual number immediately to the right (if any). Then the exploded pair is replaced by the
 * single number 0.
 *
 * This process can break the rule about each individual number being at most 9. If that happens,
 * the number is replaced by a pair, where the left member is the original value divided by 2
 * rounded down, and the right member is the original value divided by 2 rounded up.
 *
 * The last concept to incorporate is that of magnitude of a snailfish number. The magnitude of a
 * plain number is its value. The magnitude of a pair is 3 times the magnitude of the left member
 * plus 2 times the magnitude of the right member.
 *
 * The problem asks to find the magnitude resulting of adding up all the snailfish numbers in the
 * given list for part 1. For part 2, it asks finding the highest magnitude that can be generated by
 * adding up two numbers.
 *
 * The way this problem is solved here is by representing each number as a binary tree. Each node of
 * a tree can be either a `TreeNode::Number(value)` or a `TreeNode::Pair`. It is implemented with a
 * graph, so the type of the each edge "weight" is an enum that indicates whether it's the left
 * branch or the right branch. Once the number is represented this way, the implementation is more
 * or less straightforward, and details are commented below.
 */
fn main() {
    let file = if env::args()
        .skip(1)
        .next()
        .map_or(false, |flag| flag == "--sample")
    {
        include_str!("../sample.txt")
    } else {
        include_str!("../input.txt")
    };

    let numbers: Vec<Number> = file.lines().map(|line| line.parse().unwrap()).collect();
    let total_sum: Number = numbers
        .iter()
        .cloned()
        .reduce(|acc, number| acc + number)
        .unwrap();
    let part_1 = total_sum.magnitude();
    println!("Part 1: {}", part_1);

    let magnitudes = numbers.iter().enumerate().flat_map(|(i, number)| {
        numbers[i + 1..].iter().flat_map(move |another_number| {
            [
                (number.clone() + another_number.clone()).magnitude(),
                (another_number.clone() + number.clone()).magnitude(),
            ]
        })
    });
    let part_2 = magnitudes.max().unwrap();
    println!("Part 2: {}", part_2);
}

/**
 * Each number is represented as an enum that can either be a plain value, or a pair that in turn
 * can contain two numbers.
 */
#[derive(Debug, PartialEq, Clone)]
enum Number {
    Number(usize),
    Pair(Box<Number>, Box<Number>),
}

impl Number {
    fn magnitude(&self) -> usize {
        match self {
            Number::Number(n) => *n,
            Number::Pair(left, right) => 3 * left.magnitude() + 2 * right.magnitude(),
        }
    }
}

/**
 * Addition combines the two numbers in a pair, and reduces that pair as defined in the problem
 * statement.
 */
impl Add for Number {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        let new_number = Number::Pair(Box::new(self), Box::new(other));
        reduce(&new_number)
    }
}

/**
 * Parsing is done very simply and strict. Each digit pushed a `Number::Number` in a stack. A
 * closing bracket pops the two last elements of the stack and creates a pair, that goes back into
 * the stack. At the end there should be only one element in the stack, which is the final number.
 */
impl FromStr for Number {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut stack = vec![];

        for char in s.chars() {
            match char {
                ']' => {
                    let right = stack.pop().unwrap();
                    let left = stack.pop().unwrap();
                    stack.push(Number::Pair(Box::new(left), Box::new(right)));
                }
                // All numbers in the input are a single digit (otherwise the "split" rule would
                // apply)
                d if d.is_digit(10) => stack.push(Number::Number(d.to_digit(10).unwrap() as usize)),
                '[' | ',' => {}
                c => panic!("Unexpected char {}", c),
            }
        }

        Ok(stack.pop().unwrap())
    }
}

/**
 * Reduction is done internally by converting the number into a Tree, represented by a Graph. Each
 * node can be a `Number` (and contain a value) or a `Pair`. `Pair`s are empty since it will be the
 * tree the owner of the edges pointing from that node to the two numbers it contains.
 */
type TreeNumber = Graph<TreeNode, TreeEdge>;

#[derive(Debug, PartialEq)]
enum TreeNode {
    Number(usize),
    Pair,
}

/**
 * Since the tree is implemented on top of a graph from `petgraph`, this enum is used as "weights"
 * for the edges to be able to tell left from right.
 */
#[derive(PartialEq, Debug)]
enum TreeEdge {
    Left,
    Right,
}

/**
 * A number is reduced by first converting it into a tree and then iterating. We try to run the
 * "explode" rule. If it had any effect, we go back to the start of the loop. If not, we try to run
 * the "split" rule. If it had any effect, we go back to the start of the loop. If not, we're done
 * and we convert the tree to a number and return it.
 */
fn reduce(number: &Number) -> Number {
    let mut tree = number_to_tree(number);
    let mut changed = true;

    while changed {
        changed = false;

        if explode(&mut tree) {
            changed = true;
            continue;
        }

        if split(&mut tree) {
            changed = true;
            continue;
        }
    }

    tree_to_number(&tree)
}

/**
 * Exploding starts by finding the first pair that is at a depth of 4 (or higher, technically
 * speaking, but that should never happen with valid input). If there's none, there's nothing to do
 * and returns `false` (i.e. no changes).
 *
 * If there's, it finds the value immediately to the left and to the right of the pair found (see
 * `find_first_on_side` for details). If they exist, the corresponding values of the pair
 * `to_explode` are added. Then the whole `to_explode` pair is replaced by a TreeNode::Number(0).
 */
fn explode(tree: &mut TreeNumber) -> bool {
    let root = tree
        .externals(Incoming)
        .next()
        .expect("Did not find tree root");

    let to_explode = match find_pair_at_depth(root, &tree, 4) {
        Some(node) => node,
        None => return false,
    };

    let left_node = tree
        .edges(to_explode)
        .find(|edge| *edge.weight() == TreeEdge::Left)
        .expect("Did not find left edge for exploding node")
        .target();

    let right_node = tree
        .edges(to_explode)
        .find(|edge| *edge.weight() == TreeEdge::Right)
        .expect("Did not find right edge for exploding node")
        .target();

    if let Some(left_number) = find_first_on_side(to_explode, &tree, TreeEdge::Left) {
        let a = match tree[left_number] {
            TreeNode::Number(n) => n,
            _ => panic!("Tried to add non-number tree node"),
        };

        let b = match tree[left_node] {
            TreeNode::Number(n) => n,
            _ => panic!("Tried to add non-number tree node"),
        };

        tree[left_number] = TreeNode::Number(a + b);
    }

    if let Some(right_number) = find_first_on_side(to_explode, &tree, TreeEdge::Right) {
        let a = match tree[right_number] {
            TreeNode::Number(n) => n,
            _ => panic!("Tried to add non-number tree node"),
        };

        let b = match tree[right_node] {
            TreeNode::Number(n) => n,
            _ => panic!("Tried to add non-number tree node"),
        };

        tree[right_number] = TreeNode::Number(a + b);
    }

    tree[to_explode] = TreeNode::Number(0);

    true
}

/**
 * Finding a pair at the given depth is fairly straightforward - we navigate recursively decreasing
 * the depth by 1 until we find something (or not). The important part is to always explore
 * left-first, since the problem statement is explicit about starting by handling the left-most
 * pairs.
 */
fn find_pair_at_depth(from: NodeIndex, tree: &TreeNumber, depth: usize) -> Option<NodeIndex> {
    if depth == 0 {
        return match tree[from] {
            TreeNode::Pair => Some(from),
            TreeNode::Number(_) => None,
        };
    }

    let left_edge = tree
        .edges(from)
        .find(|edge| *edge.weight() == TreeEdge::Left);
    let right_edge = tree
        .edges(from)
        .find(|edge| *edge.weight() == TreeEdge::Right);

    [left_edge, right_edge]
        .iter()
        .filter_map(|edge| edge.map(|edge| edge.target()))
        .find_map(|target| find_pair_at_depth(target, tree, depth - 1))
}

/**
 * Finding the node most immediately to the side of another node is done by first going up and then
 * descending.
 *
 * For instance, given the number [[1,2],[[3,4],5]], we try to find the number immediately to the
 * left (`TreeEdge::Left`) of 3 (which should be 2). The tree representation of this number is
 * something like this:
 *
 *      A
 *     / \
 *    /   \
 *   B     \
 *  / \     C
 * 1   2   / \
 *        D   \
 *       / \   5
 *      3   4
 *
 * We start at 3. So long as we're on the left side of a node, we have to keep going up. 3 is the
 * left branch of the pair D, D is the left branch of the pair C, and C is the *right* branch of A.
 * So we stop at A, we go one step to the left (to B) and then descend to the right as much as
 * possible. That land us in 2, the number we were looking for.
 */
fn find_first_on_side(from: NodeIndex, tree: &TreeNumber, side: TreeEdge) -> Option<NodeIndex> {
    // Step 1, going up while on the opposite side of where we want to go.
    let mut opposite_edge = tree
        .edges_directed(from, Incoming)
        .find(|edge| *edge.weight() != side);

    let mut parent = tree.neighbors_directed(from, Incoming).next();

    while opposite_edge.is_none() && parent.is_some() {
        opposite_edge = tree
            .edges_directed(parent.unwrap(), Incoming)
            .find(|edge| *edge.weight() != side);
        parent = tree.neighbors_directed(parent.unwrap(), Incoming).next();
    }

    let parent = match parent {
        Some(node) => node,
        // We reached the top without ever changing sides, that means we're at a number at the edge
        // of the tree and there's nothing to add to.
        None => return None,
    };

    // Step 2, going down one step in the direction we want.
    let first_edge = tree
        .edges(parent)
        .find(|edge| *edge.weight() == side)
        .unwrap();
    let mut result = first_edge.target();

    // Step 3, going down all the way in the opposite direction until we reach the target number.
    while tree[result] == TreeNode::Pair {
        let edge = tree
            .edges(result)
            .find(|edge| *edge.weight() != side)
            .unwrap();
        result = edge.target();
    }

    Some(result)
}

/**
 * Split finds a node that is a number 10 or higher and replaces it with a pair node that is half
 * and half. The important part is in `find_greater_than`, the rest is trivial.
 */
fn split(tree: &mut TreeNumber) -> bool {
    let mut split = false;
    let root = tree
        .externals(Incoming)
        .next()
        .expect("Did not find tree root");

    if let Some(to_split) = find_greater_than(root, &tree, 9) {
        split = true;
        let value = match tree[to_split] {
            TreeNode::Number(n) => n,
            _ => panic!("Trying to split a non-number node"),
        };
        tree[to_split] = TreeNode::Pair;
        let left = tree.add_node(TreeNode::Number(value / 2));
        let right = tree.add_node(TreeNode::Number((value + 1) / 2));
        tree.add_edge(to_split, left, TreeEdge::Left);
        tree.add_edge(to_split, right, TreeEdge::Right);
    }

    split
}

/**
 * Finds the first node (starting from the left) that is higher than the given number. It's
 * important to start from the left per the problem definition.
 */
fn find_greater_than(from: NodeIndex, tree: &TreeNumber, greater_than: usize) -> Option<NodeIndex> {
    match tree[from] {
        TreeNode::Number(n) if n > greater_than => Some(from),
        TreeNode::Number(_) => None,
        TreeNode::Pair => {
            let left_edge = tree
                .edges(from)
                .find(|edge| *edge.weight() == TreeEdge::Left);
            let right_edge = tree
                .edges(from)
                .find(|edge| *edge.weight() == TreeEdge::Right);

            [left_edge, right_edge]
                .iter()
                .filter_map(|edge| edge.map(|edge| edge.target()))
                .find_map(|target| find_greater_than(target, tree, greater_than))
        }
    }
}

/**
 * Numbers and trees share the same recursive structure so both conversions imply recursively
 * traversing one while building the other.
 */
fn number_to_tree(number: &Number) -> TreeNumber {
    let mut tree = Graph::<TreeNode, TreeEdge>::new();
    insert_node(&mut tree, number);
    tree
}

fn insert_node(tree: &mut TreeNumber, number: &Number) -> NodeIndex {
    match number {
        Number::Number(value) => tree.add_node(TreeNode::Number(*value)),
        Number::Pair(left, right) => {
            let parent = tree.add_node(TreeNode::Pair);
            let left = insert_node(tree, left);
            let right = insert_node(tree, right);
            tree.add_edge(parent, left, TreeEdge::Left);
            tree.add_edge(parent, right, TreeEdge::Right);
            parent
        }
    }
}

fn tree_to_number(tree: &TreeNumber) -> Number {
    let root = tree
        .externals(Incoming)
        .next()
        .expect("Did not find tree root");

    node_to_number(root, tree)
}

fn node_to_number(node: NodeIndex, tree: &TreeNumber) -> Number {
    match tree[node] {
        TreeNode::Number(n) => Number::Number(n),
        TreeNode::Pair => {
            let left_node = tree
                .edges(node)
                .find(|edge| *edge.weight() == TreeEdge::Left)
                .expect("Did not find left edge for pair node")
                .target();

            let right_node = tree
                .edges(node)
                .find(|edge| *edge.weight() == TreeEdge::Right)
                .expect("Did not find right edge for pair node")
                .target();

            Number::Pair(
                Box::new(node_to_number(left_node, tree)),
                Box::new(node_to_number(right_node, tree)),
            )
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    macro_rules! number {
        ( $number:literal ) => {
            Number::Number($number)
        };

        ( [$left:tt, $right:tt] ) => {
            Number::Pair(Box::new(number!($left)), Box::new(number!($right)))
        };
    }

    #[test]
    fn test_explode_reduction() {
        assert_eq!(
            reduce(&number![[[[[[9, 8], 1], 2], 3], 4]]),
            number![[[[[0, 9], 2], 3], 4]]
        );

        assert_eq!(
            reduce(&number![[7, [6, [5, [4, [3, 2]]]]]]),
            number![[7, [6, [5, [7, 0]]]]]
        );

        assert_eq!(
            reduce(&number![[[6, [5, [4, [3, 2]]]], 1]]),
            number![[[6, [5, [7, 0]]], 3]]
        );

        assert_eq!(
            reduce(&number![[[3, [2, [1, [7, 3]]]], [6, [5, [4, [3, 2]]]]]]),
            number![[[3, [2, [8, 0]]], [9, [5, [7, 0]]]]]
        );
    }

    #[test]
    fn test_split() {
        assert_eq!(reduce(&number![[10, 1]]), number![[[5, 5], 1]]);
    }

    #[test]
    fn test_full_reduction() {
        assert_eq!(
            reduce(&number![[[[[[4, 3], 4], 4], [7, [[8, 4], 9]]], [1, 1]]]),
            number![[[[[0, 7], 4], [[7, 8], [6, 0]]], [8, 1]]]
        );
    }

    #[test]
    fn test_addition() {
        assert_eq!(
            number![[1, 2]] + number![[[3, 4], 5]],
            number![[[1, 2], [[3, 4], 5]]]
        );

        assert_eq!(
            number![[[[[4, 3], 4], 4], [7, [[8, 4], 9]]]] + number![[1, 1]],
            number![[[[[0, 7], 4], [[7, 8], [6, 0]]], [8, 1]]]
        );
    }

    #[test]
    fn test_magnitude() {
        assert_eq!(number![[[1, 2], [[3, 4], 5]]].magnitude(), 143);
        assert_eq!(
            number![[[[[0, 7], 4], [[7, 8], [6, 0]]], [8, 1]]].magnitude(),
            1384
        );
        assert_eq!(
            number![[[[[1, 1], [2, 2]], [3, 3]], [4, 4]]].magnitude(),
            445
        );
    }

    #[test]
    fn test_macro_simple_number() {
        assert_eq!(number![42], Number::Number(42))
    }

    #[test]
    fn test_macro_pair() {
        assert_eq!(
            number![[1, 2]],
            Number::Pair(Box::new(Number::Number(1)), Box::new(Number::Number(2)))
        )
    }

    #[test]
    fn test_macro_complex_number() {
        use Number::{Number as N, Pair as P};

        fn bn(n: usize) -> Box<Number> {
            Box::new(N(n))
        }

        fn bp(left: Box<Number>, right: Box<Number>) -> Box<Number> {
            Box::new(P(left, right))
        }

        assert_eq!(
            number![[[[[1, 2], [3, 4]], [[5, 6], [7, 8]]], 9]],
            *bp(
                bp(
                    bp(bp(bn(1), bn(2)), bp(bn(3), bn(4))),
                    bp(bp(bn(5), bn(6)), bp(bn(7), bn(8))),
                ),
                bn(9)
            )
        )
    }

    #[test]
    fn test_parse() {
        assert_eq!(
            number![[[1, 2], [[3, 4], 5]]],
            "[[1,2],[[3,4],5]]".parse().unwrap()
        );

        assert_eq!(
            number![[[[0, [5, 8]], [[1, 7], [9, 6]]], [[4, [1, 2]], [[1, 4], 2]]]],
            "[[[0,[5,8]],[[1,7],[9,6]]],[[4,[1,2]],[[1,4],2]]]"
                .parse()
                .unwrap()
        );
    }
}
